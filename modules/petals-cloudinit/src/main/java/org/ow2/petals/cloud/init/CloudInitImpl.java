/**
 *
 * Copyright (c) 2013, Linagora
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA 
 *
 */
package org.ow2.petals.cloud.init;

import com.google.common.collect.Maps;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.text.DateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

/**
 * Default implementation will get properties from a cloud-init injected file and from the IaaS metadata service.
 *
 * @author Christophe Hamerling - chamerling@linagora.com
 */
public class CloudInitImpl implements CloudInit {

    File home;

    public CloudInitImpl(File home) {
        this.home = home;
    }

    /**
     * Generates the Petals Configuration files which will be needed to start a node in the cloud environment.
     * It especially generates the server.properties file and the topology.xml plus some extra files for later use.
     */
    public void configure() throws CloudInitException {

        // get the configuration from the controller first
        String controller = getCloudControllerEndpoint();
        if (null == controller) {
            throw new CloudInitException("Can not retrieve the controller endpoint");
        }

        Map<String, String> config = getNodeConfiguration();
        File conf = new File(home, "conf");
        generateMetadataFile(new File(conf, Constants.CLOUD_FILE));
        generateServerProps(new File(conf, "server.properties"));
    }

    /**
     * Get configuration from the controller
     *
     * @return
     */
    protected Map<String,String> getNodeConfiguration() {
        Map<String, String> result = Maps.newHashMap();
        // TODO
        return result;
    }

    protected void generateMetadataFile(File file) {
        // generate a property file with all the metadata properties for later use...
        Properties props = getPlatformProperties();
        props.putAll(getUserProperties());

        try {
            props.store(new FileWriter(file), "Generated by Petals CloudInit on " + DateFormat.getInstance().format(new Date()));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Get the cloud controller endpoint which has been injected in the user metadata section
     *
     * @return
     */
    protected String getCloudControllerEndpoint() {
        return getUserProperties().getProperty(Constants.CLOUD_CONTROLLER);
    }

    /**
     *
     * @param file where to write the server properties
     */
    protected void generateServerProps(File file) {
        Map<String, String> scopes = new HashMap<String, String>();
        scopes.put("containername", getPlatformProperties().getProperty(Constants.LOCAL_IPV4));
        scopes.put("topologyURL", getPlatformProperties().getProperty(Constants.TOPOLOGY_URL));
        try {
            String out = org.ow2.petals.cloud.init.Mustache.render("server.properties.mustache", scopes);
            Writer writer = new FileWriter(file);
            writer.write(out);
            writer.flush();
            writer.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public Properties getUserProperties() {
        return MetadataClient.getUserData();
    }

    public Properties getPlatformProperties() {
        Properties props = new Properties();
        props.put(Constants.HOSTNAME, MetadataClient.get(Constants.HOSTNAME));
        props.put(Constants.LOCAL_HOSTNAME, MetadataClient.get(Constants.LOCAL_HOSTNAME));
        props.put(Constants.LOCAL_IPV4, MetadataClient.get(Constants.LOCAL_IPV4));
        props.put(Constants.PUBLIC_HOSTNAME, MetadataClient.get(Constants.PUBLIC_HOSTNAME));
        props.put(Constants.PUBLIC_IPV4, MetadataClient.get(Constants.PUBLIC_IPV4));
        return props;
    }
}
